(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/core'), require('@angular/material/core'), require('@angular/material/datepicker'), require('@angular/material/dialog'), require('rxjs'), require('rxjs/operators'), require('@angular/forms'), require('@angular/material/form-field'), require('@angular/material/input'), require('@angular/material/button'), require('@angular/material/icon'), require('@angular/cdk/platform')) :
    typeof define === 'function' && define.amd ? define('ngx-mat-datetime-picker', ['exports', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/common', '@angular/core', '@angular/material/core', '@angular/material/datepicker', '@angular/material/dialog', 'rxjs', 'rxjs/operators', '@angular/forms', '@angular/material/form-field', '@angular/material/input', '@angular/material/button', '@angular/material/icon', '@angular/cdk/platform'], factory) :
    (global = global || self, factory(global['ngx-mat-datetime-picker'] = {}, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.cdk.keycodes, global.ng.cdk.overlay, global.ng.cdk.portal, global.ng.common, global.ng.core, global.ng.material.core, global.ng.material.datepicker, global.ng.material.dialog, global.rxjs, global.rxjs.operators, global.ng.forms, global.ng.material.formField, global.ng.material.input, global.ng.material.button, global.ng.material.icon, global.ng.cdk.platform));
}(this, (function (exports, bidi, coercion, keycodes, overlay, portal, common, core, core$1, datepicker, dialog, rxjs, operators, forms, formField, input, button, icon, platform) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    var NgxMatDateAdapter = /** @class */ (function (_super) {
        __extends(NgxMatDateAdapter, _super);
        function NgxMatDateAdapter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Check if two date have same time
         * @param a Date 1
         * @param b Date 2
         */
        NgxMatDateAdapter.prototype.isSameTime = function (a, b) {
            if (a == null || b == null)
                return true;
            return this.getHour(a) === this.getHour(b)
                && this.getMinute(a) === this.getMinute(b)
                && this.getSecond(a) === this.getSecond(b);
        };
        /**
         * Copy time from a date to a another date
         * @param toDate
         * @param fromDate
         */
        NgxMatDateAdapter.prototype.copyTime = function (toDate, fromDate) {
            this.setHour(toDate, this.getHour(fromDate));
            this.setMinute(toDate, this.getMinute(fromDate));
            this.setSecond(toDate, this.getSecond(fromDate));
        };
        /**
       * Compares two dates.
       * @param first The first date to compare.
       * @param second The second date to compare.
       * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
        NgxMatDateAdapter.prototype.compareDateWithTime = function (first, second, showSeconds) {
            var res = _super.prototype.compareDate.call(this, first, second) ||
                this.getHour(first) - this.getHour(second) ||
                this.getMinute(first) - this.getMinute(second);
            if (showSeconds) {
                res = res || this.getSecond(first) - this.getSecond(second);
            }
            return res;
        };
        return NgxMatDateAdapter;
    }(core$1.DateAdapter));

    var LIMIT_TIMES = {
        minHour: 0,
        maxHour: 24,
        minMinute: 0,
        maxMinute: 60,
        minSecond: 0,
        maxSecond: 60,
        meridian: 12
    };
    var MERIDIANS = {
        AM: 'AM',
        PM: 'PM'
    };
    var DEFAULT_STEP = 1;
    var DEFAULT_HOUR_PLACEHOLDER = '';
    var DEFAULT_MINUTE_PLACEHOLDER = '';
    var DEFAULT_SECOND_PLACEHOLDER = '';
    var NUMERIC_REGEX = /[^0-9]/g;
    var PATTERN_INPUT_HOUR = /^(2[0-3]|[0-1][0-9]|[0-9])$/;
    var PATTERN_INPUT_MINUTE = /^([0-5][0-9]|[0-9])$/;
    var PATTERN_INPUT_SECOND = /^([0-5][0-9]|[0-9])$/;
    function formatTwoDigitTimeValue(val) {
        var txt = val.toString();
        return txt.length > 1 ? txt : "0" + txt;
    }
    function createMissingDateImplError(provider) {
        return Error("MatDatepicker: No provider found for " + provider + ". You must import one of the following " +
            "modules at your application root: NgxMatNativeDateModule, NgxMatMomentModule, or provide a " +
            "custom implementation.");
    }
    /** Formats a range of years. */
    function formatYearRange(start, end) {
        return start + " \u2013 " + end;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var DAYS_PER_WEEK = 7;
    /**
     * An internal component used to display a single month in the datepicker.
     * @docs-private
     */
    var NgxMatMonthView = /** @class */ (function () {
        function NgxMatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
            this._changeDetectorRef = _changeDetectorRef;
            this._dateFormats = _dateFormats;
            this._dateAdapter = _dateAdapter;
            this._dir = _dir;
            /** Emits when a new date is selected. */
            this.selectedChange = new core.EventEmitter();
            /** Emits when any date is selected. */
            this._userSelection = new core.EventEmitter();
            /** Emits when any date is activated. */
            this.activeDateChange = new core.EventEmitter();
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxMatDateAdapter');
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError('MAT_DATE_FORMATS');
            }
            this._activeDate = this._dateAdapter.today();
        }
        Object.defineProperty(NgxMatMonthView.prototype, "activeDate", {
            /**
             * The date to display in this month view (everything other than the month and year is ignored).
             */
            get: function () { return this._activeDate; },
            set: function (value) {
                var oldActiveDate = this._activeDate;
                var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                    this._init();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMonthView.prototype, "selected", {
            /** The currently selected date. */
            get: function () { return this._selected; },
            set: function (value) {
                this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._selectedDate = this._getDateInCurrentMonth(this._selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMonthView.prototype, "minDate", {
            /** The minimum selectable date. */
            get: function () { return this._minDate; },
            set: function (value) {
                this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMonthView.prototype, "maxDate", {
            /** The maximum selectable date. */
            get: function () { return this._maxDate; },
            set: function (value) {
                this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        NgxMatMonthView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /** Handles when a new date is selected. */
        NgxMatMonthView.prototype._dateSelected = function (date) {
            if (this._selectedDate != date) {
                var selectedYear = this._dateAdapter.getYear(this.activeDate);
                var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                this.selectedChange.emit(selectedDate);
            }
            this._userSelection.emit();
        };
        /** Handles keydown events on the calendar body when calendar is in month view. */
        NgxMatMonthView.prototype._handleCalendarBodyKeydown = function (event) {
            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
            // disabled ones from being selected. This may not be ideal, we should look into whether
            // navigation should skip over disabled dates, and if so, how to implement that efficiently.
            var oldActiveDate = this._activeDate;
            var isRtl = this._isRtl();
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                    break;
                case keycodes.UP_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                    break;
                case keycodes.DOWN_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                    break;
                case keycodes.HOME:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                    break;
                case keycodes.END:
                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                        this._dateAdapter.getDate(this._activeDate)));
                    break;
                case keycodes.PAGE_UP:
                    this.activeDate = event.altKey ?
                        this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                        this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                    break;
                case keycodes.PAGE_DOWN:
                    this.activeDate = event.altKey ?
                        this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                        this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                    break;
                case keycodes.ENTER:
                case keycodes.SPACE:
                    if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                        this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                        this._userSelection.emit();
                        // Prevent unexpected default actions such as form submission.
                        event.preventDefault();
                    }
                    return;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                this.activeDateChange.emit(this.activeDate);
            }
            this._focusActiveCell();
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        /** Initializes this month view. */
        NgxMatMonthView.prototype._init = function () {
            this._selectedDate = this._getDateInCurrentMonth(this.selected);
            this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
            this._monthLabel =
                this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                    .toLocaleUpperCase();
            var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
            this._firstWeekOffset =
                (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                    this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
            this._initWeekdays();
            this._createWeekCells();
            this._changeDetectorRef.markForCheck();
        };
        /** Focuses the active cell after the microtask queue is empty. */
        NgxMatMonthView.prototype._focusActiveCell = function () {
            this._matCalendarBody._focusActiveCell();
        };
        /** Initializes the weekdays. */
        NgxMatMonthView.prototype._initWeekdays = function () {
            var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
            var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
            var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
            // Rotate the labels for days of the week based on the configured first day of the week.
            var weekdays = longWeekdays.map(function (long, i) {
                return { long: long, narrow: narrowWeekdays[i] };
            });
            this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
        };
        /** Creates MatCalendarCells for the dates in this month. */
        NgxMatMonthView.prototype._createWeekCells = function () {
            var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
            var dateNames = this._dateAdapter.getDateNames();
            this._weeks = [[]];
            for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                if (cell == DAYS_PER_WEEK) {
                    this._weeks.push([]);
                    cell = 0;
                }
                var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                var enabled = this._shouldEnableDate(date);
                var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                var cellClasses = this.dateClass ? this.dateClass(date) : undefined;
                this._weeks[this._weeks.length - 1]
                    .push(new datepicker.MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));
            }
        };
        /** Date filter for the month */
        NgxMatMonthView.prototype._shouldEnableDate = function (date) {
            return !!date &&
                (!this.dateFilter || this.dateFilter(date)) &&
                (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
        };
        /**
         * Gets the date in this month that the given Date falls on.
         * Returns null if the given Date is in another month.
         */
        NgxMatMonthView.prototype._getDateInCurrentMonth = function (date) {
            return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                this._dateAdapter.getDate(date) : null;
        };
        /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */
        NgxMatMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {
            return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatMonthView.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        /** Determines whether the user has the RTL layout direction. */
        NgxMatMonthView.prototype._isRtl = function () {
            return this._dir && this._dir.value === 'rtl';
        };
        NgxMatMonthView.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_FORMATS,] }] },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMonthView.prototype, "activeDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMonthView.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMonthView.prototype, "minDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMonthView.prototype, "maxDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatMonthView.prototype, "dateFilter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatMonthView.prototype, "dateClass", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMonthView.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMonthView.prototype, "_userSelection", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMonthView.prototype, "activeDateChange", void 0);
        __decorate([
            core.ViewChild(datepicker.MatCalendarBody, { static: true }),
            __metadata("design:type", datepicker.MatCalendarBody)
        ], NgxMatMonthView.prototype, "_matCalendarBody", void 0);
        NgxMatMonthView = __decorate([
            core.Component({
                selector: 'ngx-mat-month-view',
                template: "<table class=\"mat-calendar-table\" role=\"presentation\">\r\n  <thead class=\"mat-calendar-table-header\">\r\n    <tr>\r\n      <th scope=\"col\" *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th>\r\n    </tr>\r\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr>\r\n  </thead>\r\n  <tbody mat-calendar-body\r\n         [label]=\"_monthLabel\"\r\n         [rows]=\"_weeks\"\r\n         [todayValue]=\"_todayDate!\"\r\n         [selectedValue]=\"_selectedDate!\"\r\n         [labelMinRequiredCells]=\"3\"\r\n         [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\"\r\n         (selectedValueChange)=\"_dateSelected($event)\"\r\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\r\n  </tbody>\r\n</table>\r\n",
                exportAs: 'ngxMatMonthView',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Optional()), __param(1, core.Inject(core$1.MAT_DATE_FORMATS)),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __metadata("design:paramtypes", [core.ChangeDetectorRef, Object, NgxMatDateAdapter,
                bidi.Directionality])
        ], NgxMatMonthView);
        return NgxMatMonthView;
    }());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var yearsPerPage = 24;
    var yearsPerRow = 4;
    /**
     * An internal component used to display a year selector in the datepicker.
     * @docs-private
     */
    var NgxMatMultiYearView = /** @class */ (function () {
        function NgxMatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
            this._changeDetectorRef = _changeDetectorRef;
            this._dateAdapter = _dateAdapter;
            this._dir = _dir;
            /** Emits when a new year is selected. */
            this.selectedChange = new core.EventEmitter();
            /** Emits the selected year. This doesn't imply a change on the selected date */
            this.yearSelected = new core.EventEmitter();
            /** Emits when any date is activated. */
            this.activeDateChange = new core.EventEmitter();
            this._activeDate = this._dateAdapter.today();
        }
        Object.defineProperty(NgxMatMultiYearView.prototype, "activeDate", {
            /** The date to display in this multi-year view (everything other than the year is ignored). */
            get: function () { return this._activeDate; },
            set: function (value) {
                var oldActiveDate = this._activeDate;
                var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {
                    this._init();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMultiYearView.prototype, "selected", {
            /** The currently selected date. */
            get: function () { return this._selected; },
            set: function (value) {
                this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMultiYearView.prototype, "minDate", {
            /** The minimum selectable date. */
            get: function () { return this._minDate; },
            set: function (value) {
                this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatMultiYearView.prototype, "maxDate", {
            /** The maximum selectable date. */
            get: function () { return this._maxDate; },
            set: function (value) {
                this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        NgxMatMultiYearView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /** Initializes this multi-year view. */
        NgxMatMultiYearView.prototype._init = function () {
            var _this = this;
            this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
            // We want a range years such that we maximize the number of
            // enabled dates visible at once. This prevents issues where the minimum year
            // is the last item of a page OR the maximum year is the first item of a page.
            // The offset from the active year to the "slot" for the starting year is the
            // *actual* first rendered year in the multi-year view.
            var activeYear = this._dateAdapter.getYear(this._activeDate);
            var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
            this._years = [];
            for (var i = 0, row = []; i < yearsPerPage; i++) {
                row.push(minYearOfPage + i);
                if (row.length == yearsPerRow) {
                    this._years.push(row.map(function (year) { return _this._createCellForYear(year); }));
                    row = [];
                }
            }
            this._changeDetectorRef.markForCheck();
        };
        /** Handles when a new year is selected. */
        NgxMatMultiYearView.prototype._yearSelected = function (year) {
            this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
            var month = this._dateAdapter.getMonth(this.activeDate);
            var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
            this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
        };
        /** Handles keydown events on the calendar body when calendar is in multi-year view. */
        NgxMatMultiYearView.prototype._handleCalendarBodyKeydown = function (event) {
            var oldActiveDate = this._activeDate;
            var isRtl = this._isRtl();
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                    break;
                case keycodes.UP_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                    break;
                case keycodes.DOWN_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                    break;
                case keycodes.HOME:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));
                    break;
                case keycodes.END:
                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);
                    break;
                case keycodes.PAGE_UP:
                    this.activeDate =
                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                    break;
                case keycodes.PAGE_DOWN:
                    this.activeDate =
                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                    break;
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                    break;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                this.activeDateChange.emit(this.activeDate);
            }
            this._focusActiveCell();
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        NgxMatMultiYearView.prototype._getActiveCell = function () {
            return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
        };
        /** Focuses the active cell after the microtask queue is empty. */
        NgxMatMultiYearView.prototype._focusActiveCell = function () {
            this._matCalendarBody._focusActiveCell();
        };
        /** Creates an MatCalendarCell for the given year. */
        NgxMatMultiYearView.prototype._createCellForYear = function (year) {
            var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
            return new datepicker.MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
        };
        /** Whether the given year is enabled. */
        NgxMatMultiYearView.prototype._shouldEnableYear = function (year) {
            // disable if the year is greater than maxDate lower than minDate
            if (year === undefined || year === null ||
                (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                return false;
            }
            // enable if it reaches here and there's no filter defined
            if (!this.dateFilter) {
                return true;
            }
            var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
            // If any date in the year is enabled count the year as enabled.
            for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                if (this.dateFilter(date)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatMultiYearView.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        /** Determines whether the user has the RTL layout direction. */
        NgxMatMultiYearView.prototype._isRtl = function () {
            return this._dir && this._dir.value === 'rtl';
        };
        NgxMatMultiYearView.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMultiYearView.prototype, "activeDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMultiYearView.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMultiYearView.prototype, "minDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatMultiYearView.prototype, "maxDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatMultiYearView.prototype, "dateFilter", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMultiYearView.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMultiYearView.prototype, "yearSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatMultiYearView.prototype, "activeDateChange", void 0);
        __decorate([
            core.ViewChild(datepicker.MatCalendarBody, { static: true }),
            __metadata("design:type", datepicker.MatCalendarBody)
        ], NgxMatMultiYearView.prototype, "_matCalendarBody", void 0);
        NgxMatMultiYearView = __decorate([
            core.Component({
                selector: 'ngx-mat-multi-year-view',
                template: "<table class=\"mat-calendar-table\" role=\"presentation\">\r\n  <thead class=\"mat-calendar-table-header\">\r\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\r\n  </thead>\r\n  <tbody mat-calendar-body\r\n         [rows]=\"_years\"\r\n         [todayValue]=\"_todayYear\"\r\n         [selectedValue]=\"_selectedYear!\"\r\n         [numCols]=\"4\"\r\n         [cellAspectRatio]=\"4 / 7\"\r\n         [activeCell]=\"_getActiveCell()\"\r\n         (selectedValueChange)=\"_yearSelected($event)\"\r\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\r\n  </tbody>\r\n</table>\r\n",
                exportAs: 'ngxMatMultiYearView',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Optional()),
            __param(2, core.Optional()),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                NgxMatDateAdapter,
                bidi.Directionality])
        ], NgxMatMultiYearView);
        return NgxMatMultiYearView;
    }());
    function isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {
        var year1 = dateAdapter.getYear(date1);
        var year2 = dateAdapter.getYear(date2);
        var startingYear = getStartingYear(dateAdapter, minDate, maxDate);
        return Math.floor((year1 - startingYear) / yearsPerPage) ===
            Math.floor((year2 - startingYear) / yearsPerPage);
    }
    /**
     * When the multi-year view is first opened, the active year will be in view.
     * So we compute how many years are between the active year and the *slot* where our
     * "startingYear" will render when paged into view.
     */
    function getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {
        var activeYear = dateAdapter.getYear(activeDate);
        return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);
    }
    /**
     * We pick a "starting" year such that either the maximum year would be at the end
     * or the minimum year would be at the beginning of a page.
     */
    function getStartingYear(dateAdapter, minDate, maxDate) {
        var startingYear = 0;
        if (maxDate) {
            var maxYear = dateAdapter.getYear(maxDate);
            startingYear = maxYear - yearsPerPage + 1;
        }
        else if (minDate) {
            startingYear = dateAdapter.getYear(minDate);
        }
        return startingYear;
    }
    /** Gets remainder that is non-negative, even if first number is negative */
    function euclideanModulo(a, b) {
        return (a % b + b) % b;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An internal component used to display a single year in the datepicker.
     * @docs-private
     */
    var NgxMatYearView = /** @class */ (function () {
        function NgxMatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
            this._changeDetectorRef = _changeDetectorRef;
            this._dateFormats = _dateFormats;
            this._dateAdapter = _dateAdapter;
            this._dir = _dir;
            /** Emits when a new month is selected. */
            this.selectedChange = new core.EventEmitter();
            /** Emits the selected month. This doesn't imply a change on the selected date */
            this.monthSelected = new core.EventEmitter();
            /** Emits when any date is activated. */
            this.activeDateChange = new core.EventEmitter();
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxMatDateAdapter');
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError('MAT_DATE_FORMATS');
            }
            this._activeDate = this._dateAdapter.today();
        }
        Object.defineProperty(NgxMatYearView.prototype, "activeDate", {
            /** The date to display in this year view (everything other than the year is ignored). */
            get: function () { return this._activeDate; },
            set: function (value) {
                var oldActiveDate = this._activeDate;
                var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                    this._init();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatYearView.prototype, "selected", {
            /** The currently selected date. */
            get: function () { return this._selected; },
            set: function (value) {
                this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._selectedMonth = this._getMonthInCurrentYear(this._selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatYearView.prototype, "minDate", {
            /** The minimum selectable date. */
            get: function () { return this._minDate; },
            set: function (value) {
                this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatYearView.prototype, "maxDate", {
            /** The maximum selectable date. */
            get: function () { return this._maxDate; },
            set: function (value) {
                this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        NgxMatYearView.prototype.ngAfterContentInit = function () {
            this._init();
        };
        /** Handles when a new month is selected. */
        NgxMatYearView.prototype._monthSelected = function (month) {
            var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
            this.monthSelected.emit(normalizedDate);
            var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
            this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
        };
        /** Handles keydown events on the calendar body when calendar is in year view. */
        NgxMatYearView.prototype._handleCalendarBodyKeydown = function (event) {
            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
            // disabled ones from being selected. This may not be ideal, we should look into whether
            // navigation should skip over disabled dates, and if so, how to implement that efficiently.
            var oldActiveDate = this._activeDate;
            var isRtl = this._isRtl();
            switch (event.keyCode) {
                case keycodes.LEFT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                    break;
                case keycodes.RIGHT_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                    break;
                case keycodes.UP_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                    break;
                case keycodes.DOWN_ARROW:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                    break;
                case keycodes.HOME:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                    break;
                case keycodes.END:
                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                    break;
                case keycodes.PAGE_UP:
                    this.activeDate =
                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                    break;
                case keycodes.PAGE_DOWN:
                    this.activeDate =
                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                    break;
                case keycodes.ENTER:
                case keycodes.SPACE:
                    this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                    break;
                default:
                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                    return;
            }
            if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                this.activeDateChange.emit(this.activeDate);
            }
            this._focusActiveCell();
            // Prevent unexpected default actions such as form submission.
            event.preventDefault();
        };
        /** Initializes this year view. */
        NgxMatYearView.prototype._init = function () {
            var _this = this;
            this._selectedMonth = this._getMonthInCurrentYear(this.selected);
            this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
            this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
            var monthNames = this._dateAdapter.getMonthNames('short');
            // First row of months only contains 5 elements so we can fit the year label on the same row.
            this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });
            this._changeDetectorRef.markForCheck();
        };
        /** Focuses the active cell after the microtask queue is empty. */
        NgxMatYearView.prototype._focusActiveCell = function () {
            this._matCalendarBody._focusActiveCell();
        };
        /**
         * Gets the month in this year that the given Date falls on.
         * Returns null if the given Date is in another year.
         */
        NgxMatYearView.prototype._getMonthInCurrentYear = function (date) {
            return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                this._dateAdapter.getMonth(date) : null;
        };
        /** Creates an MatCalendarCell for the given month. */
        NgxMatYearView.prototype._createCellForMonth = function (month, monthName) {
            var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
            return new datepicker.MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
        };
        /** Whether the given month is enabled. */
        NgxMatYearView.prototype._shouldEnableMonth = function (month) {
            var activeYear = this._dateAdapter.getYear(this.activeDate);
            if (month === undefined || month === null ||
                this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                return false;
            }
            if (!this.dateFilter) {
                return true;
            }
            var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
            // If any date in the month is enabled count the month as enabled.
            for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                if (this.dateFilter(date)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Tests whether the combination month/year is after this.maxDate, considering
         * just the month and year of this.maxDate
         */
        NgxMatYearView.prototype._isYearAndMonthAfterMaxDate = function (year, month) {
            if (this.maxDate) {
                var maxYear = this._dateAdapter.getYear(this.maxDate);
                var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                return year > maxYear || (year === maxYear && month > maxMonth);
            }
            return false;
        };
        /**
         * Tests whether the combination month/year is before this.minDate, considering
         * just the month and year of this.minDate
         */
        NgxMatYearView.prototype._isYearAndMonthBeforeMinDate = function (year, month) {
            if (this.minDate) {
                var minYear = this._dateAdapter.getYear(this.minDate);
                var minMonth = this._dateAdapter.getMonth(this.minDate);
                return year < minYear || (year === minYear && month < minMonth);
            }
            return false;
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatYearView.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        /** Determines whether the user has the RTL layout direction. */
        NgxMatYearView.prototype._isRtl = function () {
            return this._dir && this._dir.value === 'rtl';
        };
        NgxMatYearView.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_FORMATS,] }] },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatYearView.prototype, "activeDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatYearView.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatYearView.prototype, "minDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatYearView.prototype, "maxDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatYearView.prototype, "dateFilter", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatYearView.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatYearView.prototype, "monthSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatYearView.prototype, "activeDateChange", void 0);
        __decorate([
            core.ViewChild(datepicker.MatCalendarBody, { static: true }),
            __metadata("design:type", datepicker.MatCalendarBody)
        ], NgxMatYearView.prototype, "_matCalendarBody", void 0);
        NgxMatYearView = __decorate([
            core.Component({
                selector: 'ngx-mat-year-view',
                template: "<table class=\"mat-calendar-table\" role=\"presentation\">\r\n  <thead class=\"mat-calendar-table-header\">\r\n    <tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr>\r\n  </thead>\r\n  <tbody mat-calendar-body\r\n         [label]=\"_yearLabel\"\r\n         [rows]=\"_months\"\r\n         [todayValue]=\"_todayMonth!\"\r\n         [selectedValue]=\"_selectedMonth!\"\r\n         [labelMinRequiredCells]=\"2\"\r\n         [numCols]=\"4\"\r\n         [cellAspectRatio]=\"4 / 7\"\r\n         [activeCell]=\"_dateAdapter.getMonth(activeDate)\"\r\n         (selectedValueChange)=\"_monthSelected($event)\"\r\n         (keydown)=\"_handleCalendarBodyKeydown($event)\">\r\n  </tbody>\r\n</table>\r\n",
                exportAs: 'ngxMatYearView',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Optional()), __param(1, core.Inject(core$1.MAT_DATE_FORMATS)),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __metadata("design:paramtypes", [core.ChangeDetectorRef, Object, NgxMatDateAdapter,
                bidi.Directionality])
        ], NgxMatYearView);
        return NgxMatYearView;
    }());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** Default header for NgxMatCalendar */
    var NgxMatCalendarHeader = /** @class */ (function () {
        function NgxMatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
            this._intl = _intl;
            this.calendar = calendar;
            this._dateAdapter = _dateAdapter;
            this._dateFormats = _dateFormats;
            this.calendar.stateChanges.subscribe(function () { return changeDetectorRef.markForCheck(); });
        }
        Object.defineProperty(NgxMatCalendarHeader.prototype, "periodButtonText", {
            /** The label for the current calendar view. */
            get: function () {
                if (this.calendar.currentView == 'month') {
                    return this._dateAdapter
                        .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                        .toLocaleUpperCase();
                }
                if (this.calendar.currentView == 'year') {
                    return this._dateAdapter.getYearName(this.calendar.activeDate);
                }
                // The offset from the active year to the "slot" for the starting year is the
                // *actual* first rendered year in the multi-year view, and the last year is
                // just yearsPerPage - 1 away.
                var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
                var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);
                var maxYearOfPage = minYearOfPage + yearsPerPage - 1;
                var minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));
                var maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));
                return formatYearRange(minYearName, maxYearName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendarHeader.prototype, "periodButtonLabel", {
            get: function () {
                return this.calendar.currentView == 'month' ?
                    this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendarHeader.prototype, "prevButtonLabel", {
            /** The label for the previous button. */
            get: function () {
                return {
                    'month': this._intl.prevMonthLabel,
                    'year': this._intl.prevYearLabel,
                    'multi-year': this._intl.prevMultiYearLabel
                }[this.calendar.currentView];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendarHeader.prototype, "nextButtonLabel", {
            /** The label for the next button. */
            get: function () {
                return {
                    'month': this._intl.nextMonthLabel,
                    'year': this._intl.nextYearLabel,
                    'multi-year': this._intl.nextMultiYearLabel
                }[this.calendar.currentView];
            },
            enumerable: true,
            configurable: true
        });
        /** Handles user clicks on the period label. */
        NgxMatCalendarHeader.prototype.currentPeriodClicked = function () {
            this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
        };
        /** Handles user clicks on the previous button. */
        NgxMatCalendarHeader.prototype.previousClicked = function () {
            this.calendar.activeDate = this.calendar.currentView == 'month' ?
                this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
        };
        /** Handles user clicks on the next button. */
        NgxMatCalendarHeader.prototype.nextClicked = function () {
            this.calendar.activeDate = this.calendar.currentView == 'month' ?
                this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
        };
        /** Whether the previous period button is enabled. */
        NgxMatCalendarHeader.prototype.previousEnabled = function () {
            if (!this.calendar.minDate) {
                return true;
            }
            return !this.calendar.minDate ||
                !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
        };
        /** Whether the next period button is enabled. */
        NgxMatCalendarHeader.prototype.nextEnabled = function () {
            return !this.calendar.maxDate ||
                !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
        };
        /** Whether the two dates represent the same view in the current view mode (month or year). */
        NgxMatCalendarHeader.prototype._isSameView = function (date1, date2) {
            if (this.calendar.currentView == 'month') {
                return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                    this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
            }
            if (this.calendar.currentView == 'year') {
                return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
            }
            // Otherwise we are in 'multi-year' view.
            return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);
        };
        NgxMatCalendarHeader.ctorParameters = function () { return [
            { type: datepicker.MatDatepickerIntl },
            { type: NgxMatCalendar, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return NgxMatCalendar; }),] }] },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_FORMATS,] }] },
            { type: core.ChangeDetectorRef }
        ]; };
        NgxMatCalendarHeader = __decorate([
            core.Component({
                selector: 'ngx-mat-calendar-header',
                template: "<div class=\"mat-calendar-header\">\r\n  <div class=\"mat-calendar-controls\">\r\n    <button mat-button type=\"button\" class=\"mat-calendar-period-button\"\r\n            (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\"\r\n            cdkAriaLive=\"polite\">\r\n      {{periodButtonText}}\r\n      <div class=\"mat-calendar-arrow\"\r\n           [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div>\r\n    </button>\r\n\r\n    <div class=\"mat-calendar-spacer\"></div>\r\n\r\n    <ng-content></ng-content>\r\n\r\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\"\r\n            [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\"\r\n            [attr.aria-label]=\"prevButtonLabel\">\r\n    </button>\r\n\r\n    <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\"\r\n            [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\"\r\n            [attr.aria-label]=\"nextButtonLabel\">\r\n    </button>\r\n  </div>\r\n</div>\r\n",
                exportAs: 'ngxMatCalendarHeader',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __param(1, core.Inject(core.forwardRef(function () { return NgxMatCalendar; }))),
            __param(2, core.Optional()),
            __param(3, core.Optional()), __param(3, core.Inject(core$1.MAT_DATE_FORMATS)),
            __metadata("design:paramtypes", [datepicker.MatDatepickerIntl,
                NgxMatCalendar,
                NgxMatDateAdapter, Object, core.ChangeDetectorRef])
        ], NgxMatCalendarHeader);
        return NgxMatCalendarHeader;
    }());
    /**
     * A calendar that is used as part of the datepicker.
     * @docs-private
     */
    var NgxMatCalendar = /** @class */ (function () {
        function NgxMatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
            var _this = this;
            this._dateAdapter = _dateAdapter;
            this._dateFormats = _dateFormats;
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Used for scheduling that focus should be moved to the active cell on the next tick.
             * We need to schedule it, rather than do it immediately, because we have to wait
             * for Angular to re-evaluate the view children.
             */
            this._moveFocusOnNextTick = false;
            /** Whether the calendar should be started in month or year view. */
            this.startView = 'month';
            /** Emits when the currently selected date changes. */
            this.selectedChange = new core.EventEmitter();
            /**
             * Emits the year chosen in multiyear view.
             * This doesn't imply a change on the selected date.
             */
            this.yearSelected = new core.EventEmitter();
            /**
             * Emits the month chosen in year view.
             * This doesn't imply a change on the selected date.
             */
            this.monthSelected = new core.EventEmitter();
            /** Emits when any date is selected. */
            this._userSelection = new core.EventEmitter();
            /**
             * Emits whenever there is a state change that the header may need to respond to.
             */
            this.stateChanges = new rxjs.Subject();
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxDateAdapter');
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError('MAT_DATE_FORMATS');
            }
            this._intlChanges = _intl.changes.subscribe(function () {
                _changeDetectorRef.markForCheck();
                _this.stateChanges.next();
            });
        }
        Object.defineProperty(NgxMatCalendar.prototype, "startAt", {
            /** A date representing the period (month or year) to start the calendar in. */
            get: function () { return this._startAt; },
            set: function (value) {
                this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendar.prototype, "selected", {
            /** The currently selected date. */
            get: function () { return this._selected; },
            set: function (value) {
                this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendar.prototype, "minDate", {
            /** The minimum selectable date. */
            get: function () { return this._minDate; },
            set: function (value) {
                this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendar.prototype, "maxDate", {
            /** The maximum selectable date. */
            get: function () { return this._maxDate; },
            set: function (value) {
                this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendar.prototype, "activeDate", {
            /**
             * The current active date. This determines which time period is shown and which date is
             * highlighted when using keyboard navigation.
             */
            get: function () { return this._clampedActiveDate; },
            set: function (value) {
                this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
                this.stateChanges.next();
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatCalendar.prototype, "currentView", {
            /** Whether the calendar is in month view. */
            get: function () { return this._currentView; },
            set: function (value) {
                this._currentView = value;
                this._moveFocusOnNextTick = true;
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        NgxMatCalendar.prototype.ngAfterContentInit = function () {
            this._calendarHeaderPortal = new portal.ComponentPortal(this.headerComponent || NgxMatCalendarHeader);
            this.activeDate = this.startAt || this._dateAdapter.today();
            // Assign to the private property since we don't want to move focus on init.
            this._currentView = this.startView;
        };
        NgxMatCalendar.prototype.ngAfterViewChecked = function () {
            if (this._moveFocusOnNextTick) {
                this._moveFocusOnNextTick = false;
                this.focusActiveCell();
            }
        };
        NgxMatCalendar.prototype.ngOnDestroy = function () {
            this._intlChanges.unsubscribe();
            this.stateChanges.complete();
        };
        NgxMatCalendar.prototype.ngOnChanges = function (changes) {
            var change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];
            if (change && !change.firstChange) {
                var view = this._getCurrentViewComponent();
                if (view) {
                    // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                    // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                    this._changeDetectorRef.detectChanges();
                    view._init();
                }
            }
            this.stateChanges.next();
        };
        NgxMatCalendar.prototype.focusActiveCell = function () {
            this._getCurrentViewComponent()._focusActiveCell();
        };
        /** Updates today's date after an update of the active date */
        NgxMatCalendar.prototype.updateTodaysDate = function () {
            var view = this.currentView == 'month' ? this.monthView :
                (this.currentView == 'year' ? this.yearView : this.multiYearView);
            view.ngAfterContentInit();
        };
        /** Handles date selection in the month view. */
        NgxMatCalendar.prototype._dateSelected = function (date) {
            if (date && !this._dateAdapter.sameDate(date, this.selected)) {
                this.selectedChange.emit(date);
            }
        };
        /** Handles year selection in the multiyear view. */
        NgxMatCalendar.prototype._yearSelectedInMultiYearView = function (normalizedYear) {
            this.yearSelected.emit(normalizedYear);
        };
        /** Handles month selection in the year view. */
        NgxMatCalendar.prototype._monthSelectedInYearView = function (normalizedMonth) {
            this.monthSelected.emit(normalizedMonth);
        };
        NgxMatCalendar.prototype._userSelected = function () {
            this._userSelection.emit();
        };
        /** Handles year/month selection in the multi-year/year views. */
        NgxMatCalendar.prototype._goToDateInView = function (date, view) {
            this.activeDate = date;
            this.currentView = view;
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatCalendar.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        /** Returns the component instance that corresponds to the current calendar view. */
        NgxMatCalendar.prototype._getCurrentViewComponent = function () {
            return this.monthView || this.yearView || this.multiYearView;
        };
        NgxMatCalendar.ctorParameters = function () { return [
            { type: datepicker.MatDatepickerIntl },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_FORMATS,] }] },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatCalendar.prototype, "headerComponent", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatCalendar.prototype, "startAt", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NgxMatCalendar.prototype, "startView", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatCalendar.prototype, "selected", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatCalendar.prototype, "minDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatCalendar.prototype, "maxDate", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatCalendar.prototype, "dateFilter", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatCalendar.prototype, "dateClass", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatCalendar.prototype, "selectedChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatCalendar.prototype, "yearSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatCalendar.prototype, "monthSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatCalendar.prototype, "_userSelection", void 0);
        __decorate([
            core.ViewChild(NgxMatMonthView),
            __metadata("design:type", NgxMatMonthView)
        ], NgxMatCalendar.prototype, "monthView", void 0);
        __decorate([
            core.ViewChild(NgxMatYearView),
            __metadata("design:type", NgxMatYearView)
        ], NgxMatCalendar.prototype, "yearView", void 0);
        __decorate([
            core.ViewChild(NgxMatMultiYearView),
            __metadata("design:type", NgxMatMultiYearView)
        ], NgxMatCalendar.prototype, "multiYearView", void 0);
        NgxMatCalendar = __decorate([
            core.Component({
                selector: 'ngx-mat-calendar',
                template: "\r\n<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template>\r\n\r\n<div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\">\r\n  <ngx-mat-month-view\r\n      *ngSwitchCase=\"'month'\"\r\n      [(activeDate)]=\"activeDate\"\r\n      [selected]=\"selected\"\r\n      [dateFilter]=\"dateFilter\"\r\n      [maxDate]=\"maxDate\"\r\n      [minDate]=\"minDate\"\r\n      [dateClass]=\"dateClass\"\r\n      (selectedChange)=\"_dateSelected($event)\"\r\n      (_userSelection)=\"_userSelected()\">\r\n  </ngx-mat-month-view>\r\n\r\n  <ngx-mat-year-view\r\n      *ngSwitchCase=\"'year'\"\r\n      [(activeDate)]=\"activeDate\"\r\n      [selected]=\"selected\"\r\n      [dateFilter]=\"dateFilter\"\r\n      [maxDate]=\"maxDate\"\r\n      [minDate]=\"minDate\"\r\n      (monthSelected)=\"_monthSelectedInYearView($event)\"\r\n      (selectedChange)=\"_goToDateInView($event, 'month')\">\r\n  </ngx-mat-year-view>\r\n\r\n  <ngx-mat-multi-year-view\r\n      *ngSwitchCase=\"'multi-year'\"\r\n      [(activeDate)]=\"activeDate\"\r\n      [selected]=\"selected\"\r\n      [dateFilter]=\"dateFilter\"\r\n      [maxDate]=\"maxDate\"\r\n      [minDate]=\"minDate\"\r\n      (yearSelected)=\"_yearSelectedInMultiYearView($event)\"\r\n      (selectedChange)=\"_goToDateInView($event, 'year')\">\r\n  </ngx-mat-multi-year-view>\r\n</div>\r\n",
                host: {
                    'class': 'mat-calendar',
                },
                exportAs: 'ngxMatCalendar',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0}.mat-calendar-content{padding:0 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:\"\";margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:\"\";position:absolute;top:0;left:-8px;right:-8px;height:1px}"]
            }),
            __param(1, core.Optional()),
            __param(2, core.Optional()), __param(2, core.Inject(core$1.MAT_DATE_FORMATS)),
            __metadata("design:paramtypes", [datepicker.MatDatepickerIntl,
                NgxMatDateAdapter, Object, core.ChangeDetectorRef])
        ], NgxMatCalendar);
        return NgxMatCalendar;
    }());

    var NgxMatTimepickerComponent = /** @class */ (function () {
        function NgxMatTimepickerComponent(_dateAdapter, cd, formBuilder) {
            this._dateAdapter = _dateAdapter;
            this.cd = cd;
            this.formBuilder = formBuilder;
            this.disabled = false;
            this.showSpinners = true;
            this.hourPlaceholder = DEFAULT_HOUR_PLACEHOLDER;
            this.minutePlaceholder = DEFAULT_MINUTE_PLACEHOLDER;
            this.secondPlaceholder = DEFAULT_SECOND_PLACEHOLDER;
            this.stepHour = DEFAULT_STEP;
            this.stepMinute = DEFAULT_STEP;
            this.stepSecond = DEFAULT_STEP;
            this.showSeconds = false;
            this.enableMeridian = false;
            this.color = 'primary';
            this.meridian = MERIDIANS.AM;
            this._onChange = function () { };
            this._onTouched = function () { };
            this._destroyed = new rxjs.Subject();
            this.pattern = PATTERN_INPUT_HOUR;
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxMatDateAdapter');
            }
            this.form = this.formBuilder.group({
                hour: [{ value: null, disabled: this.disabled }, [forms.Validators.required, forms.Validators.pattern(PATTERN_INPUT_HOUR)]],
                minute: [{ value: null, disabled: this.disabled }, [forms.Validators.required, forms.Validators.pattern(PATTERN_INPUT_MINUTE)]],
                second: [{ value: null, disabled: this.disabled }, [forms.Validators.required, forms.Validators.pattern(PATTERN_INPUT_SECOND)]]
            });
        }
        NgxMatTimepickerComponent_1 = NgxMatTimepickerComponent;
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "hour", {
            /** Hour */
            get: function () {
                var val = Number(this.form.controls['hour'].value);
                return isNaN(val) ? 0 : val;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "minute", {
            get: function () {
                var val = Number(this.form.controls['minute'].value);
                return isNaN(val) ? 0 : val;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "second", {
            get: function () {
                var val = Number(this.form.controls['second'].value);
                return isNaN(val) ? 0 : val;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "valid", {
            /** Whether or not the form is valid */
            get: function () {
                return this.form.valid;
            },
            enumerable: true,
            configurable: true
        });
        NgxMatTimepickerComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.form.valueChanges.pipe(operators.takeUntil(this._destroyed), operators.debounceTime(400)).subscribe(function (val) {
                _this._updateModel();
            });
        };
        NgxMatTimepickerComponent.prototype.ngOnChanges = function (changes) {
            if (changes.disabled && !changes.disabled.firstChange) {
                this.disabled ? this.form.disable() : this.form.enable();
            }
        };
        NgxMatTimepickerComponent.prototype.ngOnDestroy = function () {
            this._destroyed.next();
            this._destroyed.complete();
        };
        /**
         * Writes a new value to the element.
         * @param obj
         */
        NgxMatTimepickerComponent.prototype.writeValue = function (val) {
            this._model = val || this._dateAdapter.today();
            this._updateHourMinuteSecond();
        };
        /** Registers a callback function that is called when the control's value changes in the UI. */
        NgxMatTimepickerComponent.prototype.registerOnChange = function (fn) {
            this._onChange = fn;
        };
        /**
         * Set the function to be called when the control receives a touch event.
         */
        NgxMatTimepickerComponent.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        /** Enables or disables the appropriate DOM element */
        NgxMatTimepickerComponent.prototype.setDisabledState = function (isDisabled) {
            this._disabled = isDisabled;
            this.cd.markForCheck();
        };
        /**
         * Format input
         * @param input
         */
        NgxMatTimepickerComponent.prototype.formatInput = function (input) {
            input.value = input.value.replace(NUMERIC_REGEX, '');
        };
        /** Toggle meridian */
        NgxMatTimepickerComponent.prototype.toggleMeridian = function () {
            this.meridian = (this.meridian === MERIDIANS.AM) ? MERIDIANS.PM : MERIDIANS.AM;
            this.change('hour');
        };
        /** Change property of time */
        NgxMatTimepickerComponent.prototype.change = function (prop, up) {
            var next = this._getNextValueByProp(prop, up);
            this.form.controls[prop].setValue(formatTwoDigitTimeValue(next), { onlySelf: false, emitEvent: false });
            this._updateModel();
        };
        /** Update controls of form by model */
        NgxMatTimepickerComponent.prototype._updateHourMinuteSecond = function () {
            var _hour = this._dateAdapter.getHour(this._model);
            var _minute = this._dateAdapter.getMinute(this._model);
            var _second = this._dateAdapter.getSecond(this._model);
            if (this.enableMeridian) {
                if (_hour > LIMIT_TIMES.meridian) {
                    _hour = _hour - LIMIT_TIMES.meridian;
                    this.meridian = MERIDIANS.PM;
                }
                else {
                    this.meridian = MERIDIANS.AM;
                }
            }
            this.form.controls['hour'].setValue(formatTwoDigitTimeValue(_hour));
            this.form.controls['minute'].setValue(formatTwoDigitTimeValue(_minute));
            this.form.controls['second'].setValue(formatTwoDigitTimeValue(_second));
        };
        /** Update model */
        NgxMatTimepickerComponent.prototype._updateModel = function () {
            var _hour = this.hour;
            if (this.enableMeridian && this.meridian === MERIDIANS.PM && _hour !== LIMIT_TIMES.meridian) {
                _hour = _hour + LIMIT_TIMES.meridian;
            }
            this._dateAdapter.setHour(this._model, _hour);
            this._dateAdapter.setMinute(this._model, this.minute);
            this._dateAdapter.setSecond(this._model, this.second);
            this._onChange(this._model);
        };
        /**
         * Get next value by property
         * @param prop
         * @param up
         */
        NgxMatTimepickerComponent.prototype._getNextValueByProp = function (prop, up) {
            var keyProp = prop[0].toUpperCase() + prop.slice(1);
            var min = LIMIT_TIMES["min" + keyProp];
            var max = LIMIT_TIMES["max" + keyProp];
            if (prop === 'hour' && this.enableMeridian) {
                max = LIMIT_TIMES.meridian;
            }
            var next;
            if (up == null) {
                next = this[prop] % (max);
            }
            else {
                next = up ? this[prop] + this["step" + keyProp] : this[prop] - this["step" + keyProp];
                if (prop === 'hour' && this.enableMeridian) {
                    next = next % (max + 1);
                    if (next === 0)
                        next = up ? 1 : max;
                }
                else {
                    next = next % max;
                }
                if (up) {
                    next = next > max ? (next - max + min) : next;
                }
                else {
                    next = next < min ? (next - min + max) : next;
                }
            }
            return next;
        };
        var NgxMatTimepickerComponent_1;
        NgxMatTimepickerComponent.ctorParameters = function () { return [
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: core.ChangeDetectorRef },
            { type: forms.FormBuilder }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "showSpinners", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "hourPlaceholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "minutePlaceholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "secondPlaceholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NgxMatTimepickerComponent.prototype, "stepHour", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NgxMatTimepickerComponent.prototype, "stepMinute", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Number)
        ], NgxMatTimepickerComponent.prototype, "stepSecond", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "showSeconds", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatTimepickerComponent.prototype, "enableMeridian", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NgxMatTimepickerComponent.prototype, "color", void 0);
        NgxMatTimepickerComponent = NgxMatTimepickerComponent_1 = __decorate([
            core.Component({
                selector: 'ngx-mat-timepicker',
                template: "<form [formGroup]=\"form\">\r\n  <table class=\"table\">\r\n    <tbody class=\"tbody\">\r\n      <tr *ngIf=\"showSpinners\">\r\n        <td>\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_less icon\" (click)=\"change('hour', true)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_less</mat-icon>\r\n          </button>\r\n        </td>\r\n        <td></td>\r\n        <td>\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_less icon\" (click)=\"change('minute', true)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_less</mat-icon>\r\n          </button> </td>\r\n        <td></td>\r\n        <td *ngIf=\"showSeconds\">\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_less icon\" (click)=\"change('second', true)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_less</mat-icon>\r\n          </button>\r\n        </td>\r\n        <td *ngIf=\"enableMeridian\" class=\"spacer\"></td>\r\n        <td *ngIf=\"enableMeridian\"></td>\r\n      </tr>\r\n\r\n      <tr>\r\n        <td>\r\n          <mat-form-field>\r\n            <input type=\"text\" matInput (input)=\"formatInput($any($event).target)\" maxlength=\"2\" formControlName=\"hour\"\r\n              [placeholder]=\"hourPlaceholder\" (keydown.ArrowUp)=\"change('hour', true); $event.preventDefault()\"\r\n              (keydown.ArrowDown)=\"change('hour', false); $event.preventDefault()\" (blur)=\"change('hour')\">\r\n          </mat-form-field>\r\n        </td>\r\n        <td class=\"spacer\">&#58;</td>\r\n        <td>\r\n          <mat-form-field>\r\n            <input type=\"text\" matInput (input)=\"formatInput($any($event).target)\" maxlength=\"2\"\r\n              formControlName=\"minute\" (keydown.ArrowUp)=\"change('minute', true); $event.preventDefault()\"\r\n              (keydown.ArrowDown)=\"change('minute', false); $event.preventDefault()\" (blur)=\"change('minute')\">\r\n          </mat-form-field>\r\n        </td>\r\n        <td *ngIf=\"showSeconds\" class=\"spacer\">&#58;</td>\r\n        <td *ngIf=\"showSeconds\">\r\n          <mat-form-field>\r\n            <input type=\"text\" matInput (input)=\"formatInput($any($event).target)\" maxlength=\"2\"\r\n              formControlName=\"second\" (keydown.ArrowUp)=\"change('second', true); $event.preventDefault()\"\r\n              (keydown.ArrowDown)=\"change('second', false); $event.preventDefault()\" (blur)=\"change('second')\">\r\n          </mat-form-field>\r\n        </td>\r\n\r\n        <td *ngIf=\"enableMeridian\" class=\"spacer\"></td>\r\n        <td *ngIf=\"enableMeridian\" class=\"meridian\">\r\n          <button mat-button (click)=\"toggleMeridian()\" mat-stroked-button [color]=\"color\" [disabled]=\"disabled\">\r\n            {{meridian}}\r\n          </button>\r\n        </td>\r\n      </tr>\r\n\r\n      <tr *ngIf=\"showSpinners\">\r\n        <td>\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_more icon\" (click)=\"change('hour', false)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_more</mat-icon>\r\n          </button> </td>\r\n        <td></td>\r\n        <td>\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_more icon\" (click)=\"change('minute', false)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_more</mat-icon>\r\n          </button> </td>\r\n        <td *ngIf=\"showSeconds\"></td>\r\n        <td *ngIf=\"showSeconds\">\r\n          <button type=\"button\" mat-icon-button aria-label=\"expand_more icon\" (click)=\"change('second', false)\"\r\n            [disabled]=\"disabled\">\r\n            <mat-icon>expand_more</mat-icon>\r\n          </button>\r\n        </td>\r\n        <td *ngIf=\"enableMeridian\" class=\"spacer\"></td>\r\n        <td *ngIf=\"enableMeridian\"></td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</form>",
                host: {
                    'class': 'ngx-mat-timepicker'
                },
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: core.forwardRef(function () { return NgxMatTimepickerComponent_1; }),
                        multi: true
                    }
                ],
                exportAs: 'ngxMatTimepicker',
                encapsulation: core.ViewEncapsulation.None,
                styles: [".ngx-mat-timepicker{font-size:13px}.ngx-mat-timepicker form{min-width:90px}.ngx-mat-timepicker form .table .tbody tr td{text-align:center}.ngx-mat-timepicker form .table .tbody tr td.spacer{font-weight:700}.ngx-mat-timepicker form .table .tbody tr td.meridian .mat-button{min-width:64px;line-height:36px;border-radius:50%;min-width:0;width:36px;height:36px;padding:0;flex-shrink:0}.ngx-mat-timepicker form .table .tbody tr td .mat-icon-button{height:24px;width:24px;line-height:24px}.ngx-mat-timepicker form .table .tbody tr td .mat-icon-button .mat-icon{font-size:24px}.ngx-mat-timepicker form .table .tbody tr td .mat-form-field{width:20px;max-width:20px;text-align:center}"]
            }),
            __param(0, core.Optional()),
            __metadata("design:paramtypes", [NgxMatDateAdapter,
                core.ChangeDetectorRef, forms.FormBuilder])
        ], NgxMatTimepickerComponent);
        return NgxMatTimepickerComponent;
    }());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** Used to generate a unique ID for each datepicker instance. */
    var datepickerUid = 0;
    // Boilerplate for applying mixins to MatDatepickerContent.
    /** @docs-private */
    var MatDatepickerContentBase = /** @class */ (function () {
        function MatDatepickerContentBase(_elementRef) {
            this._elementRef = _elementRef;
        }
        return MatDatepickerContentBase;
    }());
    var _MatDatepickerContentMixinBase = core$1.mixinColor(MatDatepickerContentBase);
    /**
     * Component used as the content for the datepicker dialog and popup. We use this instead of using
     * NgxMatCalendar directly as the content so we can control the initial focus. This also gives us a
     * place to put additional features of the popup that are not part of the calendar itself in the
     * future. (e.g. confirmation buttons).
     * @docs-private
     */
    var NgxMatDatetimeContent = /** @class */ (function (_super) {
        __extends(NgxMatDatetimeContent, _super);
        function NgxMatDatetimeContent(elementRef) {
            return _super.call(this, elementRef) || this;
        }
        Object.defineProperty(NgxMatDatetimeContent.prototype, "valid", {
            /** Whether or not the selected date is valid (min,max...) */
            get: function () {
                return this._timePicker && this._timePicker.valid && this.datepicker.valid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeContent.prototype, "isCurrentViewMonth", {
            get: function () {
                return this._calendar && (!this._calendar.currentView || this._calendar.currentView == 'month');
            },
            enumerable: true,
            configurable: true
        });
        NgxMatDatetimeContent.prototype.ngAfterViewInit = function () {
            this._calendar.focusActiveCell();
        };
        NgxMatDatetimeContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.ViewChild(NgxMatCalendar, { static: true }),
            __metadata("design:type", NgxMatCalendar)
        ], NgxMatDatetimeContent.prototype, "_calendar", void 0);
        __decorate([
            core.ViewChild(NgxMatTimepickerComponent),
            __metadata("design:type", NgxMatTimepickerComponent)
        ], NgxMatDatetimeContent.prototype, "_timePicker", void 0);
        NgxMatDatetimeContent = __decorate([
            core.Component({
                selector: 'ngx-mat-datetime-content',
                template: "<ngx-mat-calendar cdkTrapFocus [id]=\"datepicker.id\" [ngClass]=\"datepicker.panelClass\" [startAt]=\"datepicker.startAt\"\r\n    [startView]=\"datepicker.startView\" [minDate]=\"datepicker._minDate\" [maxDate]=\"datepicker._maxDate\"\r\n    [dateFilter]=\"datepicker._dateFilter\" [headerComponent]=\"datepicker.calendarHeaderComponent\"\r\n    [selected]=\"datepicker._selected\" [dateClass]=\"datepicker.dateClass\" [@fadeInCalendar]=\"'enter'\"\r\n    (selectedChange)=\"datepicker.select($event)\" (yearSelected)=\"datepicker._selectYear($event)\"\r\n    (monthSelected)=\"datepicker._selectMonth($event)\">\r\n</ngx-mat-calendar>\r\n<ng-container *ngIf=\"isCurrentViewMonth\">\r\n    <div class=\"time-container\" [class.disable-seconds]=\"!datepicker._showSeconds\">\r\n        <ngx-mat-timepicker [showSpinners]=\"datepicker._showSpinners\" [showSeconds]=\"datepicker._showSeconds\"\r\n            [disabled]=\"datepicker._disabled\" [stepHour]=\"datepicker._stepHour\" [stepMinute]=\"datepicker._stepMinute\"\r\n            [stepSecond]=\"datepicker._stepSecond\" [(ngModel)]=\"datepicker._selected\" [color]=\"datepicker._color\"\r\n            [enableMeridian]=\"datepicker._enableMeridian\">\r\n        </ngx-mat-timepicker>\r\n    </div>\r\n    <div class=\"actions\">\r\n        <button mat-button (click)=\"datepicker.ok()\" mat-stroked-button [color]=\"datepicker._color\" cdkFocusInitial\r\n            [disabled]=\"!valid\">\r\n            <mat-icon>done</mat-icon>\r\n        </button>\r\n    </div>\r\n</ng-container>",
                host: {
                    'class': 'mat-datepicker-content',
                    '[@transformPanel]': '"enter"',
                    '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                },
                animations: [
                    datepicker.matDatepickerAnimations.transformPanel,
                    datepicker.matDatepickerAnimations.fadeInCalendar,
                ],
                exportAs: 'ngxMatDatetimeContent',
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                inputs: ['color'],
                styles: [".mat-datepicker-content{display:block;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);background-color:#fff;color:rgba(0,0,0,.87)}.mat-datepicker-content .mat-calendar{width:296px}.mat-datepicker-content .time-container{display:flex;position:relative;padding-top:5px;justify-content:center}.mat-datepicker-content .time-container.disable-seconds .ngx-mat-timepicker .table{margin-left:9px}.mat-datepicker-content .time-container::before{content:\"\";position:absolute;top:0;left:0;right:0;height:1px;background-color:rgba(0,0,0,.12)}.mat-datepicker-content .actions{display:flex;padding:5px 15px 10px;justify-content:flex-end}"]
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], NgxMatDatetimeContent);
        return NgxMatDatetimeContent;
    }(_MatDatepickerContentMixinBase));
    // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
    // template reference variables (e.g. #d vs #d="matDatepicker"). We can change this to a directive
    // if angular adds support for `exportAs: '$implicit'` on directives.
    /** Component responsible for managing the datepicker popup/dialog. */
    var NgxMatDatetimePicker = /** @class */ (function () {
        function NgxMatDatetimePicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {
            var _this = this;
            this._dialog = _dialog;
            this._overlay = _overlay;
            this._ngZone = _ngZone;
            this._viewContainerRef = _viewContainerRef;
            this._dateAdapter = _dateAdapter;
            this._dir = _dir;
            this._document = _document;
            /** The view that the calendar should start in. */
            this.startView = 'month';
            this._touchUi = false;
            /**
             * Emits selected year in multiyear view.
             * This doesn't imply a change on the selected date.
             */
            this.yearSelected = new core.EventEmitter();
            /**
             * Emits selected month in year view.
             * This doesn't imply a change on the selected date.
             */
            this.monthSelected = new core.EventEmitter();
            /** Emits when the datepicker has been opened. */
            this.openedStream = new core.EventEmitter();
            /** Emits when the datepicker has been closed. */
            this.closedStream = new core.EventEmitter();
            this._opened = false;
            this._showSpinners = true;
            this._showSeconds = false;
            this._stepHour = DEFAULT_STEP;
            this._stepMinute = DEFAULT_STEP;
            this._stepSecond = DEFAULT_STEP;
            this._enableMeridian = false;
            this._hasBackdrop = true;
            /** The id for the datepicker calendar. */
            this.id = "mat-datepicker-" + datepickerUid++;
            this._validSelected = null;
            /** The element that was focused before the datepicker was opened. */
            this._focusedElementBeforeOpen = null;
            /** Subscription to value changes in the associated input element. */
            this._inputSubscription = rxjs.Subscription.EMPTY;
            /** Emits when the datepicker is disabled. */
            this._disabledChange = new rxjs.Subject();
            /** Emits new selected date when selected date changes. */
            this._selectedChanged = new rxjs.Subject();
            /** The form control validator for the min date. */
            this._minValidator = function () {
                return (!_this._minDate || !_this._selected ||
                    _this._dateAdapter.compareDateWithTime(_this._minDate, _this._selected, _this.showSeconds) <= 0) ?
                    null : { 'matDatetimePickerMin': { 'min': _this._minDate, 'actual': _this._selected } };
            };
            /** The form control validator for the max date. */
            this._maxValidator = function () {
                return (!_this._maxDate || !_this._selected ||
                    _this._dateAdapter.compareDateWithTime(_this._maxDate, _this._selected, _this.showSeconds) >= 0) ?
                    null : { 'matDatetimePickerMax': { 'max': _this._maxDate, 'actual': _this._selected } };
            };
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxMatDateAdapter');
            }
            this._scrollStrategy = scrollStrategy;
        }
        Object.defineProperty(NgxMatDatetimePicker.prototype, "startAt", {
            /** The date to open the calendar to initially. */
            get: function () {
                // If an explicit startAt is set we start there, otherwise we start at whatever the currently
                // selected value is.
                return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
            },
            set: function (value) {
                this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "color", {
            /** Color palette to use on the datepicker's calendar. */
            get: function () {
                return this._color ||
                    (this._datepickerInput ? this._datepickerInput._getThemePalette() : 'primary');
            },
            set: function (value) {
                this._color = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "touchUi", {
            /**
             * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
             * than a popup and elements have more padding to allow for bigger touch targets.
             */
            get: function () { return this._touchUi; },
            set: function (value) {
                this._touchUi = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "disabled", {
            /** Whether the datepicker pop-up should be disabled. */
            get: function () {
                return this._disabled === undefined && this._datepickerInput ?
                    this._datepickerInput.disabled : !!this._disabled;
            },
            set: function (value) {
                var newValue = coercion.coerceBooleanProperty(value);
                if (newValue !== this._disabled) {
                    this._disabled = newValue;
                    this._disabledChange.next(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "opened", {
            /** Whether the calendar is open. */
            get: function () { return this._opened; },
            set: function (value) { value ? this.open() : this.close(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "showSpinners", {
            /** Whether the timepicker'spinners is shown. */
            get: function () { return this._showSpinners; },
            set: function (value) { this._showSpinners = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "showSeconds", {
            /** Whether the second part is disabled. */
            get: function () { return this._showSeconds; },
            set: function (value) { this._showSeconds = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "stepHour", {
            /** Step hour */
            get: function () { return this._stepHour; },
            set: function (value) { this._stepHour = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "stepMinute", {
            /** Step minute */
            get: function () { return this._stepMinute; },
            set: function (value) { this._stepMinute = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "stepSecond", {
            /** Step second */
            get: function () { return this._stepSecond; },
            set: function (value) { this._stepSecond = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "enableMeridian", {
            /** Enable meridian */
            get: function () { return this._enableMeridian; },
            set: function (value) { this._enableMeridian = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "_selected", {
            /** The currently selected date. */
            get: function () { return this._validSelected; },
            set: function (value) { this._validSelected = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "_minDate", {
            /** The minimum selectable date. */
            get: function () {
                return this._datepickerInput && this._datepickerInput.min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "_maxDate", {
            /** The maximum selectable date. */
            get: function () {
                return this._datepickerInput && this._datepickerInput.max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "valid", {
            get: function () {
                var minValidators = this._minValidator();
                var maxValidators = this._maxValidator();
                return minValidators == null && maxValidators == null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimePicker.prototype, "_dateFilter", {
            get: function () {
                return this._datepickerInput && this._datepickerInput._dateFilter;
            },
            enumerable: true,
            configurable: true
        });
        NgxMatDatetimePicker.prototype.ngOnDestroy = function () {
            this.close();
            this._inputSubscription.unsubscribe();
            this._disabledChange.complete();
            if (this._popupRef) {
                this._popupRef.dispose();
                this._popupComponentRef = null;
            }
        };
        /** Selects the given date */
        NgxMatDatetimePicker.prototype.select = function (date) {
            this._dateAdapter.copyTime(date, this._selected);
            this._selected = date;
        };
        /** Emits the selected year in multiyear view */
        NgxMatDatetimePicker.prototype._selectYear = function (normalizedYear) {
            this.yearSelected.emit(normalizedYear);
        };
        /** Emits selected month in year view */
        NgxMatDatetimePicker.prototype._selectMonth = function (normalizedMonth) {
            this.monthSelected.emit(normalizedMonth);
        };
        /** OK button handler and close*/
        NgxMatDatetimePicker.prototype.ok = function () {
            var cloned = this._dateAdapter.clone(this._selected);
            this._selectedChanged.next(cloned);
            this.close();
        };
        /** Cancel and close */
        NgxMatDatetimePicker.prototype.cancel = function () {
            this._selected = this._rawValue;
            this.close();
        };
        /**
         * Register an input with this datepicker.
         * @param input The datepicker input to register with this datepicker.
         */
        NgxMatDatetimePicker.prototype._registerInput = function (input) {
            var _this = this;
            if (this._datepickerInput) {
                throw Error('A MatDatepicker can only be associated with a single input.');
            }
            this._datepickerInput = input;
            this._inputSubscription =
                this._datepickerInput._valueChange.subscribe(function (value) { return _this._selected = value; });
        };
        /** Open the calendar. */
        NgxMatDatetimePicker.prototype.open = function () {
            this._rawValue = this._selected != null
                ? this._dateAdapter.clone(this._selected) : null;
            if (this._selected == null) {
                this._selected = this._dateAdapter.today();
            }
            if (this._opened || this.disabled) {
                return;
            }
            if (!this._datepickerInput) {
                throw Error('Attempted to open an MatDatepicker with no associated input.');
            }
            if (this._document) {
                this._focusedElementBeforeOpen = this._document.activeElement;
            }
            this.touchUi ? this._openAsDialog() : this._openAsPopup();
            this._opened = true;
            this.openedStream.emit();
        };
        /** Close the calendar. */
        NgxMatDatetimePicker.prototype.close = function () {
            var _this = this;
            if (!this._opened) {
                return;
            }
            if (this._popupRef && this._popupRef.hasAttached()) {
                this._popupRef.detach();
            }
            if (this._dialogRef) {
                this._dialogRef.close();
                this._dialogRef = null;
            }
            if (this._calendarPortal && this._calendarPortal.isAttached) {
                this._calendarPortal.detach();
            }
            var completeClose = function () {
                // The `_opened` could've been reset already if
                // we got two events in quick succession.
                if (_this._opened) {
                    _this._opened = false;
                    _this.closedStream.emit();
                    _this._focusedElementBeforeOpen = null;
                }
            };
            if (this._focusedElementBeforeOpen &&
                typeof this._focusedElementBeforeOpen.focus === 'function') {
                // Because IE moves focus asynchronously, we can't count on it being restored before we've
                // marked the datepicker as closed. If the event fires out of sequence and the element that
                // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                // able to close the calendar at all. We work around it by making the logic, that marks
                // the datepicker as closed, async as well.
                this._focusedElementBeforeOpen.focus();
                setTimeout(completeClose);
            }
            else {
                completeClose();
            }
        };
        /** Open the calendar as a dialog. */
        NgxMatDatetimePicker.prototype._openAsDialog = function () {
            var _this = this;
            // Usually this would be handled by `open` which ensures that we can only have one overlay
            // open at a time, however since we reset the variables in async handlers some overlays
            // may slip through if the user opens and closes multiple times in quick succession (e.g.
            // by holding down the enter key).
            if (this._dialogRef) {
                this._dialogRef.close();
            }
            this._dialogRef = this._dialog.open(NgxMatDatetimeContent, {
                direction: this._dir ? this._dir.value : 'ltr',
                viewContainerRef: this._viewContainerRef,
                panelClass: 'mat-datepicker-dialog',
                // These values are all the same as the defaults, but we set them explicitly so that the
                // datepicker dialog behaves consistently even if the user changed the defaults.
                hasBackdrop: true,
                disableClose: false,
                width: '',
                height: '',
                minWidth: '',
                minHeight: '',
                maxWidth: '80vw',
                maxHeight: '',
                position: {},
                autoFocus: true,
                restoreFocus: true
            });
            this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });
            this._dialogRef.componentInstance.datepicker = this;
            this._setColor();
        };
        /** Open the calendar as a popup. */
        NgxMatDatetimePicker.prototype._openAsPopup = function () {
            var _this = this;
            if (!this._calendarPortal) {
                this._calendarPortal = new portal.ComponentPortal(NgxMatDatetimeContent, this._viewContainerRef);
            }
            this._destroyPopup();
            this._createPopup();
            this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
            this._popupComponentRef.instance.datepicker = this;
            this._setColor();
            // Update the position once the calendar has rendered.
            this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                _this._popupRef.updatePosition();
            });
        };
        /** Destroys the current popup overlay. */
        NgxMatDatetimePicker.prototype._destroyPopup = function () {
            if (this._popupRef) {
                this._popupRef.dispose();
                this._popupRef = this._popupComponentRef = null;
            }
        };
        /** Create the popup. */
        NgxMatDatetimePicker.prototype._createPopup = function () {
            var _this = this;
            var overlayConfig = new overlay.OverlayConfig({
                positionStrategy: this._createPopupPositionStrategy(),
                hasBackdrop: this._hasBackdrop,
                backdropClass: 'mat-overlay-transparent-backdrop',
                direction: this._dir,
                scrollStrategy: this._scrollStrategy(),
                panelClass: 'mat-datepicker-popup',
            });
            this._popupRef = this._overlay.create(overlayConfig);
            this._popupRef.overlayElement.setAttribute('role', 'dialog');
            rxjs.merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(operators.filter(function (event) {
                // Closing on alt + up is only valid when there's an input associated with the datepicker.
                return event.keyCode === keycodes.ESCAPE ||
                    (_this._datepickerInput && event.altKey && event.keyCode === keycodes.UP_ARROW);
            }))).subscribe(function (event) {
                if (event) {
                    event.preventDefault();
                }
                (_this._hasBackdrop && event) ? _this.cancel() : _this.close();
            });
        };
        /** Create the popup PositionStrategy. */
        NgxMatDatetimePicker.prototype._createPopupPositionStrategy = function () {
            return this._overlay.position()
                .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                .withTransformOriginOn('.mat-datepicker-content')
                .withFlexibleDimensions(false)
                .withViewportMargin(8)
                .withLockedPosition()
                .withPositions([
                {
                    originX: 'start',
                    originY: 'bottom',
                    overlayX: 'start',
                    overlayY: 'top'
                },
                {
                    originX: 'start',
                    originY: 'top',
                    overlayX: 'start',
                    overlayY: 'bottom'
                },
                {
                    originX: 'end',
                    originY: 'bottom',
                    overlayX: 'end',
                    overlayY: 'top'
                },
                {
                    originX: 'end',
                    originY: 'top',
                    overlayX: 'end',
                    overlayY: 'bottom'
                }
            ]);
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatDatetimePicker.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        /** Passes the current theme color along to the calendar overlay. */
        NgxMatDatetimePicker.prototype._setColor = function () {
            var color = this.color;
            if (this._popupComponentRef) {
                this._popupComponentRef.instance.color = color;
            }
            if (this._dialogRef) {
                this._dialogRef.componentInstance.color = color;
            }
        };
        NgxMatDatetimePicker.ctorParameters = function () { return [
            { type: dialog.MatDialog },
            { type: overlay.Overlay },
            { type: core.NgZone },
            { type: core.ViewContainerRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [datepicker.MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatDatetimePicker.prototype, "calendarHeaderComponent", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatDatetimePicker.prototype, "startAt", null);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], NgxMatDatetimePicker.prototype, "startView", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], NgxMatDatetimePicker.prototype, "color", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "touchUi", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "disabled", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimePicker.prototype, "yearSelected", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimePicker.prototype, "monthSelected", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], NgxMatDatetimePicker.prototype, "panelClass", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Function)
        ], NgxMatDatetimePicker.prototype, "dateClass", void 0);
        __decorate([
            core.Output('opened'),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimePicker.prototype, "openedStream", void 0);
        __decorate([
            core.Output('closed'),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimePicker.prototype, "closedStream", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "opened", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "showSpinners", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "showSeconds", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], NgxMatDatetimePicker.prototype, "stepHour", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], NgxMatDatetimePicker.prototype, "stepMinute", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], NgxMatDatetimePicker.prototype, "stepSecond", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimePicker.prototype, "enableMeridian", null);
        NgxMatDatetimePicker = __decorate([
            core.Component({
                selector: 'ngx-mat-datetime-picker',
                template: '',
                exportAs: 'ngxMatDatetimePicker',
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                encapsulation: core.ViewEncapsulation.None
            }),
            __param(4, core.Inject(datepicker.MAT_DATEPICKER_SCROLL_STRATEGY)),
            __param(5, core.Optional()),
            __param(6, core.Optional()),
            __param(7, core.Optional()), __param(7, core.Inject(common.DOCUMENT)),
            __metadata("design:paramtypes", [dialog.MatDialog,
                overlay.Overlay,
                core.NgZone,
                core.ViewContainerRef, Object, NgxMatDateAdapter,
                bidi.Directionality, Object])
        ], NgxMatDatetimePicker);
        return NgxMatDatetimePicker;
    }());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** @docs-private */
    var MAT_DATEPICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NgxMatDatetimeInput; }),
        multi: true
    };
    /** @docs-private */
    var MAT_DATEPICKER_VALIDATORS = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return NgxMatDatetimeInput; }),
        multi: true
    };
    /**
     * An event used for datepicker input and change events. We don't always have access to a native
     * input or change event because the event may have been triggered by the user clicking on the
     * calendar popup. For consistency, we always use MatDatetimePickerInputEvent instead.
     */
    var MatDatetimePickerInputEvent = /** @class */ (function () {
        function MatDatetimePickerInputEvent(
        /** Reference to the datepicker input component that emitted the event. */
        target, 
        /** Reference to the native input element associated with the datepicker input. */
        targetElement) {
            this.target = target;
            this.targetElement = targetElement;
            this.value = this.target.value;
        }
        return MatDatetimePickerInputEvent;
    }());
    /** Directive used to connect an input to a matDatetimePicker. */
    var NgxMatDatetimeInput = /** @class */ (function () {
        function NgxMatDatetimeInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
            var _this = this;
            this._elementRef = _elementRef;
            this._dateAdapter = _dateAdapter;
            this._dateFormats = _dateFormats;
            this._formField = _formField;
            /** Emits when a `change` event is fired on this `<input>`. */
            this.dateChange = new core.EventEmitter();
            /** Emits when an `input` event is fired on this `<input>`. */
            this.dateInput = new core.EventEmitter();
            /** Emits when the value changes (either due to user input or programmatic change). */
            this._valueChange = new core.EventEmitter();
            /** Emits when the disabled state has changed */
            this._disabledChange = new core.EventEmitter();
            this._onTouched = function () { };
            this._cvaOnChange = function () { };
            this._validatorOnChange = function () { };
            this._datepickerSubscription = rxjs.Subscription.EMPTY;
            this._localeSubscription = rxjs.Subscription.EMPTY;
            /** The form control validator for whether the input parses. */
            this._parseValidator = function () {
                return _this._lastValueValid ?
                    null : { 'matDatetimePickerParse': { 'text': _this._elementRef.nativeElement.value } };
            };
            /** The form control validator for the min date. */
            this._minValidator = function (control) {
                var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return (!_this.min || !controlValue ||
                    _this._dateAdapter.compareDateWithTime(_this.min, controlValue, _this._datepicker.showSeconds) <= 0) ?
                    null : { 'matDatetimePickerMin': { 'min': _this.min, 'actual': controlValue } };
            };
            /** The form control validator for the max date. */
            this._maxValidator = function (control) {
                var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return (!_this.max || !controlValue ||
                    _this._dateAdapter.compareDateWithTime(_this.max, controlValue, _this._datepicker.showSeconds) >= 0) ?
                    null : { 'matDatetimePickerMax': { 'max': _this.max, 'actual': controlValue } };
            };
            /** The form control validator for the date filter. */
            this._filterValidator = function (control) {
                var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                    null : { 'matDatetimePickerFilter': true };
            };
            /** The combined form control validator for this input. */
            this._validator = forms.Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
            /** Whether the last value set on the input was valid. */
            this._lastValueValid = false;
            if (!this._dateAdapter) {
                throw createMissingDateImplError('NgxMatDateAdapter');
            }
            if (!this._dateFormats) {
                throw createMissingDateImplError('MAT_DATE_FORMATS');
            }
            // Update the displayed date when the locale changes.
            this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {
                _this.value = _this.value;
            });
        }
        NgxMatDatetimeInput_1 = NgxMatDatetimeInput;
        Object.defineProperty(NgxMatDatetimeInput.prototype, "ngxMatDatetimePicker", {
            /** The datepicker that this input is associated with. */
            set: function (value) {
                var _this = this;
                if (!value) {
                    return;
                }
                this._datepicker = value;
                this._datepicker._registerInput(this);
                this._datepickerSubscription.unsubscribe();
                this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(function (selected) {
                    _this.value = selected;
                    _this._cvaOnChange(selected);
                    _this._onTouched();
                    _this.dateInput.emit(new MatDatetimePickerInputEvent(_this, _this._elementRef.nativeElement));
                    _this.dateChange.emit(new MatDatetimePickerInputEvent(_this, _this._elementRef.nativeElement));
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeInput.prototype, "ngxMatDatetimePickerFilter", {
            /** Function that can be used to filter out dates within the datepicker. */
            set: function (value) {
                this._dateFilter = value;
                this._validatorOnChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeInput.prototype, "value", {
            /** The value of the input. */
            get: function () { return this._value; },
            set: function (value) {
                value = this._dateAdapter.deserialize(value);
                this._lastValueValid = !value || this._dateAdapter.isValid(value);
                value = this._getValidDateOrNull(value);
                var oldDate = this.value;
                this._value = value;
                this._formatValue(value);
                if (!this._dateAdapter.sameDate(oldDate, value)) {
                    this._valueChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeInput.prototype, "min", {
            /** The minimum valid date. */
            get: function () { return this._min; },
            set: function (value) {
                this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._validatorOnChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeInput.prototype, "max", {
            /** The maximum valid date. */
            get: function () { return this._max; },
            set: function (value) {
                this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                this._validatorOnChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxMatDatetimeInput.prototype, "disabled", {
            /** Whether the datepicker-input is disabled. */
            get: function () { return !!this._disabled; },
            set: function (value) {
                var newValue = value != null && "" + value !== 'false';
                var element = this._elementRef.nativeElement;
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._disabledChange.emit(newValue);
                }
                // We need to null check the `blur` method, because it's undefined during SSR.
                if (newValue && element.blur) {
                    // Normally, native input elements automatically blur if they turn disabled. This behavior
                    // is problematic, because it would mean that it triggers another change detection cycle,
                    // which then causes a changed after checked error if the input element was focused before.
                    element.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        NgxMatDatetimeInput.prototype.ngOnDestroy = function () {
            this._datepickerSubscription.unsubscribe();
            this._localeSubscription.unsubscribe();
            this._valueChange.complete();
            this._disabledChange.complete();
        };
        /** @docs-private */
        NgxMatDatetimeInput.prototype.registerOnValidatorChange = function (fn) {
            this._validatorOnChange = fn;
        };
        /** @docs-private */
        NgxMatDatetimeInput.prototype.validate = function (c) {
            return this._validator ? this._validator(c) : null;
        };
        /**
         * @deprecated
         * @breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
         */
        NgxMatDatetimeInput.prototype.getPopupConnectionElementRef = function () {
            return this.getConnectedOverlayOrigin();
        };
        /**
         * Gets the element that the datepicker popup should be connected to.
         * @return The element to connect the popup to.
         */
        NgxMatDatetimeInput.prototype.getConnectedOverlayOrigin = function () {
            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
        };
        // Implemented as part of ControlValueAccessor.
        NgxMatDatetimeInput.prototype.writeValue = function (value) {
            this.value = value;
        };
        // Implemented as part of ControlValueAccessor.
        NgxMatDatetimeInput.prototype.registerOnChange = function (fn) {
            this._cvaOnChange = fn;
        };
        // Implemented as part of ControlValueAccessor.
        NgxMatDatetimeInput.prototype.registerOnTouched = function (fn) {
            this._onTouched = fn;
        };
        // Implemented as part of ControlValueAccessor.
        NgxMatDatetimeInput.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        NgxMatDatetimeInput.prototype._onKeydown = function (event) {
            var isAltDownArrow = event.altKey && event.keyCode === keycodes.DOWN_ARROW;
            if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                this._datepicker.open();
                event.preventDefault();
            }
        };
        NgxMatDatetimeInput.prototype._onInput = function (value) {
            var lastValueWasValid = this._lastValueValid;
            var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
            this._lastValueValid = !date || this._dateAdapter.isValid(date);
            date = this._getValidDateOrNull(date);
            var isSameTime = this._dateAdapter.isSameTime(date, this._value);
            if ((date != null && (!isSameTime || !this._dateAdapter.sameDate(date, this._value)))
                || (date == null && this._value != null)) {
                this._value = date;
                this._cvaOnChange(date);
                this._valueChange.emit(date);
                this.dateInput.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));
            }
            else if (lastValueWasValid !== this._lastValueValid) {
                this._validatorOnChange();
            }
        };
        NgxMatDatetimeInput.prototype._onChange = function () {
            this.dateChange.emit(new MatDatetimePickerInputEvent(this, this._elementRef.nativeElement));
        };
        /** Returns the palette used by the input's form field, if any. */
        NgxMatDatetimeInput.prototype._getThemePalette = function () {
            return this._formField ? this._formField.color : undefined;
        };
        /** Handles blur events on the input. */
        NgxMatDatetimeInput.prototype._onBlur = function () {
            // Reformat the input only if we have a valid value.
            if (this.value) {
                this._formatValue(this.value);
            }
            this._onTouched();
        };
        /** Handles focus events on the input. */
        NgxMatDatetimeInput.prototype._onFocus = function () {
            // Close datetime picker if opened
            if (this._datepicker && this._datepicker.opened) {
                this._datepicker.cancel();
            }
        };
        /** Formats a value and sets it on the input element. */
        NgxMatDatetimeInput.prototype._formatValue = function (value) {
            this._elementRef.nativeElement.value =
                value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
        };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        NgxMatDatetimeInput.prototype._getValidDateOrNull = function (obj) {
            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
        };
        var NgxMatDatetimeInput_1;
        NgxMatDatetimeInput.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: NgxMatDateAdapter, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_FORMATS,] }] },
            { type: formField.MatFormField, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", NgxMatDatetimePicker),
            __metadata("design:paramtypes", [NgxMatDatetimePicker])
        ], NgxMatDatetimeInput.prototype, "ngxMatDatetimePicker", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Function])
        ], NgxMatDatetimeInput.prototype, "ngxMatDatetimePickerFilter", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatDatetimeInput.prototype, "value", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatDatetimeInput.prototype, "min", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], NgxMatDatetimeInput.prototype, "max", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], NgxMatDatetimeInput.prototype, "disabled", null);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimeInput.prototype, "dateChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", core.EventEmitter)
        ], NgxMatDatetimeInput.prototype, "dateInput", void 0);
        NgxMatDatetimeInput = NgxMatDatetimeInput_1 = __decorate([
            core.Directive({
                selector: 'input[ngxMatDatetimePicker]',
                providers: [
                    MAT_DATEPICKER_VALUE_ACCESSOR,
                    MAT_DATEPICKER_VALIDATORS,
                    { provide: input.MAT_INPUT_VALUE_ACCESSOR, useExisting: NgxMatDatetimeInput_1 },
                ],
                host: {
                    '[attr.aria-haspopup]': '_datepicker ? "dialog" : null',
                    '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                    '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                    '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                    '[disabled]': 'disabled',
                    '(input)': '_onInput($event.target.value)',
                    '(change)': '_onChange()',
                    '(blur)': '_onBlur()',
                    '(focus)': '_onFocus()',
                    '(keydown)': '_onKeydown($event)',
                },
                exportAs: 'ngxMatDatetimePickerInput',
            }),
            __param(1, core.Optional()),
            __param(2, core.Optional()), __param(2, core.Inject(core$1.MAT_DATE_FORMATS)),
            __param(3, core.Optional()),
            __metadata("design:paramtypes", [core.ElementRef,
                NgxMatDateAdapter, Object, formField.MatFormField])
        ], NgxMatDatetimeInput);
        return NgxMatDatetimeInput;
    }());

    var NgxMatTimepickerModule = /** @class */ (function () {
        function NgxMatTimepickerModule() {
        }
        NgxMatTimepickerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    input.MatInputModule,
                    forms.ReactiveFormsModule,
                    forms.FormsModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                ],
                exports: [
                    NgxMatTimepickerComponent
                ],
                declarations: [
                    NgxMatTimepickerComponent
                ]
            })
        ], NgxMatTimepickerModule);
        return NgxMatTimepickerModule;
    }());

    var NgxMatDatetimePickerModule = /** @class */ (function () {
        function NgxMatDatetimePickerModule() {
        }
        NgxMatDatetimePickerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    datepicker.MatDatepickerModule,
                    dialog.MatDialogModule,
                    portal.PortalModule,
                    forms.FormsModule,
                    icon.MatIconModule,
                    button.MatButtonModule,
                    input.MatInputModule,
                    NgxMatTimepickerModule
                ],
                exports: [
                    NgxMatDatetimePicker,
                    NgxMatDatetimeInput,
                    NgxMatCalendar,
                    NgxMatMonthView,
                    NgxMatYearView,
                    NgxMatMultiYearView,
                    NgxMatCalendarHeader,
                    NgxMatDatetimeContent,
                ],
                declarations: [
                    NgxMatDatetimePicker,
                    NgxMatDatetimeContent,
                    NgxMatDatetimeInput,
                    NgxMatCalendar,
                    NgxMatMonthView,
                    NgxMatYearView,
                    NgxMatMultiYearView,
                    NgxMatCalendarHeader
                ],
                entryComponents: [
                    NgxMatDatetimeContent,
                    NgxMatCalendarHeader
                ],
                providers: [
                    datepicker.MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER
                ]
            })
        ], NgxMatDatetimePickerModule);
        return NgxMatDatetimePickerModule;
    }());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // TODO(mmalerba): Remove when we no longer support safari 9.
    /** Whether the browser supports the Intl API. */
    var SUPPORTS_INTL_API;
    // We need a try/catch around the reference to `Intl`, because accessing it in some cases can
    // cause IE to throw. These cases are tied to particular versions of Windows and can happen if
    // the consumer is providing a polyfilled `Map`. See:
    // https://github.com/Microsoft/ChakraCore/issues/3189
    // https://github.com/angular/components/issues/15687
    try {
        SUPPORTS_INTL_API = typeof Intl != 'undefined';
    }
    catch (_a) {
        SUPPORTS_INTL_API = false;
    }
    /** The default month names to use if Intl API is not available. */
    var DEFAULT_MONTH_NAMES = {
        'long': [
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
            'October', 'November', 'December'
        ],
        'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
    };
    var 0 = function (i) { return String(i + 1); };
    /** The default date names to use if Intl API is not available. */
    var DEFAULT_DATE_NAMES = range(31, 0);
    /** The default day of the week names to use if Intl API is not available. */
    var DEFAULT_DAY_OF_WEEK_NAMES = {
        'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
    };
    /**
     * Matches strings that have the form of a valid RFC 3339 string
     * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date
     * because the regex will match strings an with out of bounds month, date, etc.
     */
    var ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
    /** Creates an array and fills it with values. */
    function range(length, valueFunction) {
        var valuesArray = Array(length);
        for (var i = 0; i < length; i++) {
            valuesArray[i] = valueFunction(i);
        }
        return valuesArray;
    }
    /** Adapts the native JS Date for use with cdk-based components that work with dates. */
    var NgxMatNativeDateAdapter = /** @class */ (function (_super) {
        __extends(NgxMatNativeDateAdapter, _super);
        function NgxMatNativeDateAdapter(matDateLocale, platform) {
            var _this = _super.call(this) || this;
            /**
             * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
             * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
             * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
             * will produce `'8/13/1800'`.
             *
             * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
             * getting the string representation of a Date object from its utc representation. We're keeping
             * it here for sometime, just for precaution, in case we decide to revert some of these changes
             * though.
             */
            _this.useUtcForDisplay = true;
            _super.prototype.setLocale.call(_this, matDateLocale);
            // IE does its own time zone correction, so we disable this on IE.
            _this.useUtcForDisplay = !platform.TRIDENT;
            _this._clampDate = platform.TRIDENT || platform.EDGE;
            return _this;
        }
        NgxMatNativeDateAdapter.prototype.getYear = function (date) {
            return date.getFullYear();
        };
        NgxMatNativeDateAdapter.prototype.getMonth = function (date) {
            return date.getMonth();
        };
        NgxMatNativeDateAdapter.prototype.getDate = function (date) {
            return date.getDate();
        };
        NgxMatNativeDateAdapter.prototype.getDayOfWeek = function (date) {
            return date.getDay();
        };
        NgxMatNativeDateAdapter.prototype.getMonthNames = function (style) {
            var _this = this;
            if (SUPPORTS_INTL_API) {
                var dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });
                return range(12, function (i) {
                    return _this._stripDirectionalityCharacters(_this._format(dtf_1, new Date(2017, i, 1)));
                });
            }
            return DEFAULT_MONTH_NAMES[style];
        };
        NgxMatNativeDateAdapter.prototype.getDateNames = function () {
            var _this = this;
            if (SUPPORTS_INTL_API) {
                var dtf_2 = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });
                return range(31, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_2, new Date(2017, 0, i + 1))); });
            }
            return DEFAULT_DATE_NAMES;
        };
        NgxMatNativeDateAdapter.prototype.getDayOfWeekNames = function (style) {
            var _this = this;
            if (SUPPORTS_INTL_API) {
                var dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });
                return range(7, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_3, new Date(2017, 0, i + 1))); });
            }
            return DEFAULT_DAY_OF_WEEK_NAMES[style];
        };
        NgxMatNativeDateAdapter.prototype.getYearName = function (date) {
            if (SUPPORTS_INTL_API) {
                var dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });
                return this._stripDirectionalityCharacters(this._format(dtf, date));
            }
            return String(this.getYear(date));
        };
        NgxMatNativeDateAdapter.prototype.getFirstDayOfWeek = function () {
            // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
            return 0;
        };
        NgxMatNativeDateAdapter.prototype.getNumDaysInMonth = function (date) {
            return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
        };
        NgxMatNativeDateAdapter.prototype.clone = function (date) {
            return new Date(date.getTime());
        };
        NgxMatNativeDateAdapter.prototype.createDate = function (year, month, date) {
            // Check for invalid month and date (except upper bound on date which we have to check after
            // creating the Date).
            if (month < 0 || month > 11) {
                throw Error("Invalid month index \"" + month + "\". Month index has to be between 0 and 11.");
            }
            if (date < 1) {
                throw Error("Invalid date \"" + date + "\". Date has to be greater than 0.");
            }
            var result = this._createDateWithOverflow(year, month, date);
            // Check that the date wasn't above the upper bound for the month, causing the month to overflow
            if (result.getMonth() != month) {
                throw Error("Invalid date \"" + date + "\" for month with index \"" + month + "\".");
            }
            return result;
        };
        NgxMatNativeDateAdapter.prototype.today = function () {
            return new Date();
        };
        NgxMatNativeDateAdapter.prototype.parse = function (value) {
            // We have no way using the native JS Date to set the parse format or locale, so we ignore these
            // parameters.
            if (typeof value == 'number') {
                return new Date(value);
            }
            return value ? new Date(Date.parse(value)) : null;
        };
        NgxMatNativeDateAdapter.prototype.format = function (date, displayFormat) {
            if (!this.isValid(date)) {
                throw Error('NativeDateAdapter: Cannot format invalid date.');
            }
            if (SUPPORTS_INTL_API) {
                // On IE and Edge the i18n API will throw a hard error that can crash the entire app
                // if we attempt to format a date whose year is less than 1 or greater than 9999.
                if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {
                    date = this.clone(date);
                    date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));
                }
                displayFormat = __assign(__assign({}, displayFormat), { timeZone: 'utc' });
                var dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
                return this._stripDirectionalityCharacters(this._format(dtf, date));
            }
            return this._stripDirectionalityCharacters(date.toDateString());
        };
        NgxMatNativeDateAdapter.prototype.addCalendarYears = function (date, years) {
            return this.addCalendarMonths(date, years * 12);
        };
        NgxMatNativeDateAdapter.prototype.addCalendarMonths = function (date, months) {
            var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
            // It's possible to wind up in the wrong month if the original month has more days than the new
            // month. In this case we want to go to the last day of the desired month.
            // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
            // guarantee this.
            if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
                newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
            }
            return newDate;
        };
        NgxMatNativeDateAdapter.prototype.addCalendarDays = function (date, days) {
            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
        };
        NgxMatNativeDateAdapter.prototype.toIso8601 = function (date) {
            return [
                date.getUTCFullYear(),
                this._2digit(date.getUTCMonth() + 1),
                this._2digit(date.getUTCDate())
            ].join('-');
        };
        /**
         * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
         * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
         * invalid date for all other values.
         */
        NgxMatNativeDateAdapter.prototype.deserialize = function (value) {
            if (typeof value === 'string') {
                if (!value) {
                    return null;
                }
                // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the
                // string is the right format first.
                if (ISO_8601_REGEX.test(value)) {
                    var date = new Date(value);
                    if (this.isValid(date)) {
                        return date;
                    }
                }
            }
            return _super.prototype.deserialize.call(this, value);
        };
        NgxMatNativeDateAdapter.prototype.isDateInstance = function (obj) {
            return obj instanceof Date;
        };
        NgxMatNativeDateAdapter.prototype.isValid = function (date) {
            return !isNaN(date.getTime());
        };
        NgxMatNativeDateAdapter.prototype.invalid = function () {
            return new Date(NaN);
        };
        NgxMatNativeDateAdapter.prototype.getHour = function (date) {
            return date.getHours();
        };
        NgxMatNativeDateAdapter.prototype.getMinute = function (date) {
            return date.getMinutes();
        };
        NgxMatNativeDateAdapter.prototype.getSecond = function (date) {
            return date.getSeconds();
        };
        NgxMatNativeDateAdapter.prototype.setHour = function (date, value) {
            date.setHours(value);
        };
        NgxMatNativeDateAdapter.prototype.setMinute = function (date, value) {
            date.setMinutes(value);
        };
        NgxMatNativeDateAdapter.prototype.setSecond = function (date, value) {
            date.setSeconds(value);
        };
        /** Creates a date but allows the month and date to overflow. */
        NgxMatNativeDateAdapter.prototype._createDateWithOverflow = function (year, month, date) {
            var result = new Date(year, month, date);
            // We need to correct for the fact that JS native Date treats years in range [0, 99] as
            // abbreviations for 19xx.
            if (year >= 0 && year < 100) {
                result.setFullYear(this.getYear(result) - 1900);
            }
            return result;
        };
        /**
         * Pads a number to make it two digits.
         * @param n The number to pad.
         * @returns The padded number.
         */
        NgxMatNativeDateAdapter.prototype._2digit = function (n) {
            return ('00' + n).slice(-2);
        };
        /**
         * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
         * other browsers do not. We remove them to make output consistent and because they interfere with
         * date parsing.
         * @param str The string to strip direction characters from.
         * @returns The stripped string.
         */
        NgxMatNativeDateAdapter.prototype._stripDirectionalityCharacters = function (str) {
            return str.replace(/[\u200e\u200f]/g, '');
        };
        /**
         * When converting Date object to string, javascript built-in functions may return wrong
         * results because it applies its internal DST rules. The DST rules around the world change
         * very frequently, and the current valid rule is not always valid in previous years though.
         * We work around this problem building a new Date object which has its internal UTC
         * representation with the local date and time.
         * @param dtf Intl.DateTimeFormat object, containg the desired string format. It must have
         *    timeZone set to 'utc' to work fine.
         * @param date Date from which we want to get the string representation according to dtf
         * @returns A Date object with its UTC representation based on the passed in date info
         */
        NgxMatNativeDateAdapter.prototype._format = function (dtf, date) {
            var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
            return dtf.format(d);
        };
        NgxMatNativeDateAdapter.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_DATE_LOCALE,] }] },
            { type: platform.Platform }
        ]; };
        NgxMatNativeDateAdapter = __decorate([
            core.Injectable(),
            __param(0, core.Optional()), __param(0, core.Inject(core$1.MAT_DATE_LOCALE)),
            __metadata("design:paramtypes", [String, platform.Platform])
        ], NgxMatNativeDateAdapter);
        return NgxMatNativeDateAdapter;
    }(NgxMatDateAdapter));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var DEFAULT_DATE_INPUT = {
        year: 'numeric', month: 'numeric', day: 'numeric',
        hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit"
    };
    var NGX_MAT_NATIVE_DATE_FORMATS = {
        parse: {
            dateInput: DEFAULT_DATE_INPUT,
        },
        display: {
            dateInput: DEFAULT_DATE_INPUT,
            monthYearLabel: { year: 'numeric', month: 'short' },
            dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
            monthYearA11yLabel: { year: 'numeric', month: 'long' },
        }
    };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NgxNativeDateModule = /** @class */ (function () {
        function NgxNativeDateModule() {
        }
        NgxNativeDateModule = __decorate([
            core.NgModule({
                imports: [platform.PlatformModule],
                providers: [
                    { provide: NgxMatDateAdapter, useClass: NgxMatNativeDateAdapter },
                ],
            })
        ], NgxNativeDateModule);
        return NgxNativeDateModule;
    }());
    var 0$1 = NGX_MAT_NATIVE_DATE_FORMATS;
    var NgxMatNativeDateModule = /** @class */ (function () {
        function NgxMatNativeDateModule() {
        }
        NgxMatNativeDateModule = __decorate([
            core.NgModule({
                imports: [NgxNativeDateModule],
                providers: [{ provide: core$1.MAT_DATE_FORMATS, useValue: 0$1 }],
            })
        ], NgxMatNativeDateModule);
        return NgxMatNativeDateModule;
    }());

    exports.MAT_DATEPICKER_VALIDATORS = MAT_DATEPICKER_VALIDATORS;
    exports.MAT_DATEPICKER_VALUE_ACCESSOR = MAT_DATEPICKER_VALUE_ACCESSOR;
    exports.MatDatetimePickerInputEvent = MatDatetimePickerInputEvent;
    exports.NGX_MAT_NATIVE_DATE_FORMATS = NGX_MAT_NATIVE_DATE_FORMATS;
    exports.NgxMatCalendar = NgxMatCalendar;
    exports.NgxMatCalendarHeader = NgxMatCalendarHeader;
    exports.NgxMatDateAdapter = NgxMatDateAdapter;
    exports.NgxMatDatetimeContent = NgxMatDatetimeContent;
    exports.NgxMatDatetimeInput = NgxMatDatetimeInput;
    exports.NgxMatDatetimePicker = NgxMatDatetimePicker;
    exports.NgxMatDatetimePickerModule = NgxMatDatetimePickerModule;
    exports.NgxMatMonthView = NgxMatMonthView;
    exports.NgxMatMultiYearView = NgxMatMultiYearView;
    exports.NgxMatNativeDateAdapter = NgxMatNativeDateAdapter;
    exports.NgxMatNativeDateModule = NgxMatNativeDateModule;
    exports.NgxMatTimepickerComponent = NgxMatTimepickerComponent;
    exports.NgxMatTimepickerModule = NgxMatTimepickerModule;
    exports.NgxMatYearView = NgxMatYearView;
    exports.NgxNativeDateModule = NgxNativeDateModule;
    exports.getActiveOffset = getActiveOffset;
    exports.isSameMultiYearView = isSameMultiYearView;
    exports.yearsPerPage = yearsPerPage;
    exports.yearsPerRow = yearsPerRow;
    exports.0 = 0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-mat-datetime-picker.umd.js.map
